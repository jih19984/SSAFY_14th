# 문제
"""
RGB 거리에는 집이 N개 있다. (1번 ~ N번)
집은 빨강, 파랑, 초록 중 하나의 색으로 칠해야 한다.
모든 집을 칠하는 비용의 최솟값을 구하시오.

- 1번 집의 색 != 2번 집의 색
- N번 집의 색 != N-1번 집의 색
- i번 집의 색은 i-1, i+1의 집의 색과 같지 않아야 한다.

2 <= N <= 1000

ex) 집이 3개인 경우
빨  파  초
26 40 83
49 60 57
13 89 90

...

# edge case
2줄씩 비교하게 되면 첫번째 케이스대로 가버림
19 -> 10 -> 400, 400
5 -> 300 -> 3 

26 -> (60, 57) -> (13, 90), (13, 89)
처음에 1번째 수를 고르면
두번째는 1번째 수를 제외한 2 or 3번째 수를
세번째는 2번째 수를 제외한 1 or 3번째 수를
네번째는 ...
결국 이 말의 의미는 현재 색은 이전 색과 같지만 않으면 ok를 의미


"""

# 풀이 방법
"""
시간 제한 0.5초인거 보니 dfs 바로 패스
문제 잘못 이해해서 30분 증발...

시도 1
2줄씩 비교해서 합이 최소가 되는 경우의 수를 구한다.(한 번에 경우의 수 6가지)
-> 그 다음 세번째 줄에 더하는 애가 매우 작은 경우 안됨.

시도 2
6
30 19 5
64 77 64
15 19 97
4 71 57
90 86 84
93 32 91

19  30  5 dp[0] dp[1] dp[2]
300 300 10  dp[3] = min(arr[3//3]+dp[1], arr[3//3]+dp[2]) dp[4] = min(arr[4//3]+dp[0], arr[4//3]+dp[2]) dp[5]
400 400 3   dp[6] dp[7] dp[8]

k >= 3
if k % 3 == 0
dp[k] = min(arr[k//3]+dp[k-2], arr[k//3]+dp[k-1])
elif k - 1 % 3 == 0
...
elif k - 2 % 3 == 0
"""

import sys
input = sys.stdin.readline

N = int(input())

arr = [list(map(int, input().split())) for _ in range(N)]

dp = [0] * (N*3)
dp[0] = arr[0][0]
dp[1] = arr[0][1]
dp[2] = arr[0][2]

for i in range(3, 3*N):
    if i % 3 == 0:
        dp[i] = min(arr[i//3][0]+dp[i-2], arr[i//3][0]+dp[i-1])
    elif (i-1) % 3 == 0:
        dp[i] = min(arr[i//3][1]+dp[i-2], arr[i//3][1]+dp[i-4])
    elif (i-2) % 3 == 0:
        dp[i] = min(arr[i//3][2]+dp[i-4], arr[i//3][2]+dp[i-5])

print(min(dp[3*N-1], dp[3*N-2], dp[3*N-3]))
